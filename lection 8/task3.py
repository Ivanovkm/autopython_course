# Напишите функцию segment
# На вход подается два кортежа с координатами точек (x1, y1), (x2, y2)

# В функции происходит проверка на корректность полученных данных.
# С помощью инструкции try/except as отлавливается исключение Exception. И если это исключение поймано,
# то функция возвращает текст исключения задом наперед (Нужно обратится к атрибуту экзепляра класса Exception)
# Если исключения не произошло, то функция возвращает сумму всех координат


# Здесь пишем код
def segment(tup1, tup2):
    """
    Функция принимает на вход два кортежа по два числа каждый (координаты), возвращает сумму всех координат
    :param tup1: первый кортеж координат
    :param tup2: второй кортеж координат
    :return: сумма всех координат
    """
    # Мне больше нравится так, но тогда не будет второго ожидаемого исключения:
    # try:
    #     # Т.к. функция sum всегда выдает исключение, если складываются не числа, ловим TypeError:
    #     return sum(tup1) + sum(tup2)
    # except TypeError as e:
    #     return e.__str__()[::-1]

    try:
        return tup1[0] + tup1[1] + tup2[0] + tup2[1]
    except TypeError as e:
        return e.__str__()[::-1]


# Ниже НИЧЕГО НЕ НАДО ИЗМЕНЯТЬ


data = [
    ((2, 3), (4, 5)),
    ((2, -3), (4, 5)),
    ((2, 3), ('4', 5)),
    (('a', 3), (4, 5)),
]

test_data = [
    14,
    8,
    "'rts' dna 'tni' :+ rof )s(epyt dnarepo detroppusnu",
    'rts ot )"tni" ton( rts etanetacnoc ylno nac']

for i, d in enumerate(data):
    assert segment(*d) == test_data[i], f'С набором {d} есть ошибка, не проходит проверку'
    print(f'Тестовый набор {d} прошёл проверку')
print('Всё ок')
